from __future__ import annotations

import os

from typing import Any, Dict, List, Literal, Optional, Type, TypeAlias, Union
from pydantic import BaseModel, Field, create_model  # type: ignore
from typing_extensions import TypedDict
from openai import AsyncOpenAI

from .qdoc import QDocument, Tool
from .qproxy import QProxy

Action: TypeAlias = Literal[
    "putDoc",
    "getDoc",
    "mergeDoc",
    "deleteDoc",
    "findDocs",
    "scanDocs",
    "countDocs",
    "existsDoc",
]

MAPPING = {
    "string": str,
    "integer": int,
    "number": float,
    "boolean": bool,
    "object": dict,
    "array": list,
    "null": None,
}


class Property(Tool):
    """
    Represents a property in a schema.

    Attributes:
            type (str): The type of the property.
            default (Optional[Any]): The default value of the property.
            enum (Optional[List[Any]]): The list of allowed values for the property.
            items (Optional[Property]): The schema for items in an array property.
            properties (Optional[Dict[str, Property]]): The schemas for properties in an object property.
            required (Optional[List[str]]): The list of required properties in an object property.
            title (Optional[str]): The title of the property.
    """

    type: str
    default: Optional[Any]
    enum: Optional[List[Any]]
    items: Optional[Property]
    properties: Optional[Dict[str, Property]]
    required: Optional[List[str]]
    title: Optional[str]


class JsonSchema(TypedDict, total=False):
    """
    Represents a JSON schema.

    Attributes:
            title (str): The title of the schema.
            type (Literal["object"]): The type of the schema.
            properties (Dict[str, Property]): The properties of the schema.
            required (List[str]): The required properties of the schema.
    """

    title: str
    type: Literal["object"]
    properties: Dict[str, Property]
    required: List[str]


class SynthetizeData(Tool, QProxy[AsyncOpenAI]):
    json_schema: JsonSchema = Field(
        ...,
        description="The JSON schema to generate data from",
        examples=[
            {
                "title": "JobPosting",
                "type": "object",
                "properties": {
                    "title": {"type": "string"},
                    "modality": {
                        "type": "string",
                        "enum": ["full-time", "part-time", "contract"],
                    },
                    "location": {"type": "string"},
                    "salary": {"type": "number"},
                    "remote": {"type": "boolean"},
                    "company": {
                        "type": "object",
                        "title": "Company",
                        "properties": {
                            "name": {"type": "string"},
                            "url": {"type": "string"},
                        },
                    },
                    "skills": {"type": "array", "items": {"type": "string"}},
                },
                "required": ["title", "location", "salary", "company"],
            }
        ],
    )
    n: int = Field(default=10, description="The number of samples to generate")

    async def run(self, **kwargs: Any):
        n = self.n
        model = create_model_from_json_schema(self.json_schema)
        PROMPT = f"""You are a synthetic data generator, generate exactly {n} samples according to the following schema: {model.model_json_schema()}. Output them as a json object in a the following format:
		{{"data": [*samples]}}
		The output must be valid `json` with no backticks neither additional or prior content or advicce.
		"""
        response = await ai.chat.completions.create(
            messages=[
                {"role": "system", "content": PROMPT},
                {"role": "user", "content": prompt},
            ],
            model="llama3-8B-8192",
            max_tokens=8192,
        )
        samples = response.choices[0].message.content
        if samples:
            return [
                model.model_validate(s).model_dump_json()
                for s in json.loads(samples)["data"]  # type: ignore
            ]


class TypeDef(TypedDict, total=False):
    """
    Represents a type definition.

    Attributes:
            data (Optional[Dict[str, Any]]): The data to be stored if the action is `putDoc` or `mergeDoc`.
            definition (JsonSchema): The `jsonschema` definition of the data.
    """

    data: Optional[Dict[str, Any]] = Field(
        default=None,
        description="The data to be stored if the action is `putDoc` or `mergeDoc`",
        examples=[
            {
                "title": "JobPosting",
                "modality": "full-time",
                "location": "Remote",
                "salary": 100000,
                "remote": True,
                "company": {"name": "Acme Inc.", "url": "https://acme.com"},
                "skills": ["python", "fastapi", "aws"],
            }
        ],
    )
    definition: JsonSchema = Field(
        ...,
        description="The `jsonschema` definition of the data, for more information see https://swagger.io/docs/specification/data-models",
        examples=[],
    )


def parse_anyof_oneof(schema: Dict[str, Any]) -> Union[Type[QDocument], None]:
    """
    Parses the given schema and returns a Union type representing the possible types
    specified in the 'anyOf' or 'oneOf' fields of the schema.

    Args:
            schema (Dict[str, Any]): The schema to parse.

    Returns:
            Union[Type[QDocument], None]: The Union type representing the possible types
            specified in the schema, or None if neither 'anyOf' nor 'oneOf' is present in the schema.
    """
    if "anyOf" in schema:
        return Union[
            tuple[type](cast_to_type(sub_schema) for sub_schema in schema["anyOf"])  # type: ignore
        ]
    elif "oneOf" in schema:
        return Union[
            tuple[type](cast_to_type(sub_schema) for sub_schema in schema["oneOf"])  # type: ignore
        ]
    else:
        return None


def create_oneof_validator(fields: List[str]):
    """
    Validates that exactly one field is provided in the given values dictionary.

    Args:
            fields (List[str]): The list of fields to validate.

    Returns:
            Callable[[Type[QDocument], Dict[str, Any]], Dict[str, Any]]: The validation function.
    """

    def validate_oneof(cls: Type[QDocument], values: Dict[str, Any]):
        match_count = sum(
            1 for field in fields if field in values and values[field] is not None
        )
        if match_count != 1:
            raise ValueError("Exactly one field must be provided")
        return values

    return validate_oneof


def cast_to_type(schema: Dict[str, Any]) -> Any:
    """
    Casts a JSON schema to its corresponding Python type.

    Args:
            schema (Dict[str, Any]): The JSON schema to cast.

    Returns:
            Any: The corresponding Python type.

    """
    if "enum" in schema:
        enum_values = tuple(schema["enum"])
        if all(isinstance(value, type(enum_values[0])) for value in enum_values):
            return Literal[enum_values]  # type: ignore
    elif schema.get("type") == "object":
        if schema.get("properties"):
            return json_schema_to_qmodel(schema)  # type: ignore
    elif schema.get("type") == "array":
        return List[cast_to_type(schema.get("items", {}))]
    else:
        return MAPPING.get(schema.get("type", "string"), str)
    return Any


def json_schema_to_qmodel(
    schema: JsonSchema,
    action: Action,
) -> Type[QDocument]:
    """
    Creates a Pydantic model from a JSON schema.

    Args:
            schema (JsonSchema): The JSON schema to create the model from.
            partial (bool, optional): Whether the model should allow partial data. Defaults to False.

    Returns:
            Type[QDocument]: The Pydantic model created from the JSON schema.
    """
    name = schema.get("title", "Model")
    properties = schema.get("properties", {})
    attributes: Dict[str, Any] = {}
    if not action in ("mergeDoc", "findDocs"):
        for key, value in properties.items():
            attributes[key] = (cast_to_type(value), ...)  # type: ignore
    else:
        for key, value in properties.items():
            attributes[key] = (Optional[cast_to_type(value)], None)  # type: ignore
    return create_model(name, __base__=QDocument, **attributes)  # type: ignore
